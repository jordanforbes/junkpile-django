// Generated by dts-bundle v0.7.3

declare module "@eslint-community/regexpp" {
  import * as AST from "@eslint-community/regexpp/ast";
  import { RegExpParser } from "@eslint-community/regexpp/parser";
  import { RegExpValidator } from "@eslint-community/regexpp/validator";
  import { RegExpVisitor } from "@eslint-community/regexpp/visitor";
  export { AST, RegExpParser, RegExpValidator };
  /**
   * Parse a given regular expression literal then make AST object.
   * @param source The source code to parse.
   * @param options The options to parse.
   * @returns The AST of the regular expression.
   */
  export function parseRegExpLiteral(
    source: RegExp | string,
    options?: RegExpParser.Options
  ): AST.RegExpLiteral;
  /**
   * Validate a given regular expression literal.
   * @param source The source code to validate.
   * @param options The options to validate.
   */
  export function validateRegExpLiteral(
    source: string,
    options?: RegExpValidator.Options
  ): void;
  export function visitRegExpAST(
    node: AST.Node,
    handlers: RegExpVisitor.Handlers
  ): void;
}

declare module "@eslint-community/regexpp/ast" {
  /**
   * The type which includes all nodes.
   */
  export type Node = BranchNode | LeafNode;
  /**
   * The type which includes all branch nodes.
   */
  export type BranchNode =
    | Alternative
    | CapturingGroup
    | CharacterClass
    | CharacterClassRange
    | ClassIntersection
    | ClassStringDisjunction
    | ClassSubtraction
    | ExpressionCharacterClass
    | Group
    | LookaroundAssertion
    | Pattern
    | Quantifier
    | RegExpLiteral
    | StringAlternative;
  /**
   * The type which includes all leaf nodes.
   */
  export type LeafNode =
    | Backreference
    | BoundaryAssertion
    | Character
    | CharacterSet
    | Flags;
  /**
   * The type which includes all atom nodes.
   */
  export type Element = Assertion | QuantifiableElement | Quantifier;
  /**
   * The type which includes all atom nodes that Quantifier node can have as children.
   */
  export type QuantifiableElement =
    | Backreference
    | CapturingGroup
    | Character
    | CharacterClass
    | CharacterSet
    | ExpressionCharacterClass
    | Group
    | LookaheadAssertion;
  /**
   * The type which includes all character class atom nodes.
   */
  export type CharacterClassElement =
    | ClassRangesCharacterClassElement
    | UnicodeSetsCharacterClassElement;
  export type ClassRangesCharacterClassElement =
    | Character
    | CharacterClassRange
    | EscapeCharacterSet
    | UnicodePropertyCharacterSet;
  export type UnicodeSetsCharacterClassElement =
    | Character
    | CharacterClassRange
    | ClassStringDisjunction
    | EscapeCharacterSet
    | ExpressionCharacterClass
    | UnicodePropertyCharacterSet
    | UnicodeSetsCharacterClass;
  /**
   * The type which defines common properties for all node types.
   */
  export interface NodeBase {
    /** The node type. */
    type: Node["type"];
    /** The parent node. */
    parent: Node["parent"];
    /** The 0-based index that this node starts. */
    start: number;
    /** The 0-based index that this node ends. */
    end: number;
    /** The raw text of this node. */
    raw: string;
  }
  /**
   * The root node.
   */
  export interface RegExpLiteral extends NodeBase {
    type: "RegExpLiteral";
    parent: null;
    pattern: Pattern;
    flags: Flags;
  }
  /**
   * The pattern.
   */
  export interface Pattern extends NodeBase {
    type: "Pattern";
    parent: RegExpLiteral | null;
    alternatives: Alternative[];
  }
  /**
   * The alternative.
   * E.g. `a|b`
   */
  export interface Alternative extends NodeBase {
    type: "Alternative";
    parent: CapturingGroup | Group | LookaroundAssertion | Pattern;
    elements: Element[];
  }
  /**
   * The uncapturing group.
   * E.g. `(?:ab)`
   */
  export interface Group extends NodeBase {
    type: "Group";
    parent: Alternative | Quantifier;
    alternatives: Alternative[];
  }
  /**
   * The capturing group.
   * E.g. `(ab)`, `(?<name>ab)`
   */
  export interface CapturingGroup extends NodeBase {
    type: "CapturingGroup";
    parent: Alternative | Quantifier;
    name: string | null;
    alternatives: Alternative[];
    references: Backreference[];
  }
  /**
   * The lookaround assertion.
   */
  export type LookaroundAssertion = LookaheadAssertion | LookbehindAssertion;
  /**
   * The lookahead assertion.
   * E.g. `(?=ab)`, `(?!ab)`
   */
  export interface LookaheadAssertion extends NodeBase {
    type: "Assertion";
    parent: Alternative | Quantifie